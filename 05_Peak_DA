###############################################
###############################################
## CLUSTER-SPECIFIC PEAK ANALYSIS BY SAMPLE
## Using Existing PeakMatrix 
###############################################
###############################################

library(ArchR)
library(ggplot2)
library(dplyr)

# Load project
projP_3 <- loadArchRProject(path = "/Volumes/DataBox2/Save-ProjP_3", force = FALSE, showLogo = FALSE)

###############################################
## 1. SETUP: Rename samples and create identifiers
###############################################

# Get and rename samples
sample <- projP_3$Sample
sample <- gsub("cortex_fresh_v1", "sample1", sample)
sample <- gsub("cortex_v1-1_chromx", "sample2", sample)
sample <- gsub("cortex_v2_chromx", "sample3", sample)
sample <- gsub("cortex_v2_cont", "sample4", sample)

# Add to project
projP_3$sample <- sample
table(projP_3$sample)

# Create combined sample_cluster identifier
projP_3$sample_cluster <- paste0(projP_3$sample, "_", projP_3$Clusters)
table(projP_3$sample_cluster)

# Get all unique clusters
all_clusters <- unique(projP_3$Clusters)
print(all_clusters)

###############################################
## 2. VERIFY EXISTING PEAK MATRIX
###############################################

# Check what matrices are available
print("Available matrices:")
print(getAvailableMatrices(projP_3))

# Verify PeakMatrix exists
if(!"PeakMatrix" %in% getAvailableMatrices(projP_3)) {
  stop("PeakMatrix not found! Please run addPeakMatrix() first.")
}

print("\nUsing existing PeakMatrix for sample-cluster comparisons")

# Get peak information
peakSet <- getPeakSet(projP_3)
print(paste("Total peaks in dataset:", length(peakSet)))

###############################################
## 3. HELPER FUNCTIONS
###############################################

# Function to find common clusters between two samples
get_common_clusters <- function(sample1_name, sample2_name) {
  sample1_combinations <- unique(projP_3$sample_cluster[projP_3$sample == sample1_name])
  sample2_combinations <- unique(projP_3$sample_cluster[projP_3$sample == sample2_name])
  
  sample1_clusters <- gsub(paste0(sample1_name, "_"), "", sample1_combinations)
  sample2_clusters <- gsub(paste0(sample2_name, "_"), "", sample2_combinations)
  
  common <- intersect(sample1_clusters, sample2_clusters)
  return(common)
}


###############################################
## 4. PEAK COMPARISON FUNCTIONS 
###############################################

# Close any open devices
while(dev.cur() > 1) dev.off()

# Function to perform cluster-specific peak comparison (BIDIRECTIONAL)
compare_peaks_by_cluster <- function(sample1_name, sample2_name, cluster_name) {
  
  print(paste("Analyzing peaks:", sample1_name, "vs", sample2_name, "in", cluster_name))
  
  # Subset to specific cluster
  clusterSubset <- projP_3[projP_3$Clusters %in% cluster_name]
  
  # Check if both samples exist in this cluster
  samples_in_cluster <- unique(clusterSubset$sample)
  if(!all(c(sample1_name, sample2_name) %in% samples_in_cluster)) {
    print(paste("  Skipping - not all samples present in", cluster_name))
    return(NULL)
  }
  
  # Check cell counts
  n_s1 <- sum(clusterSubset$sample == sample1_name)
  n_s2 <- sum(clusterSubset$sample == sample2_name)
  print(paste("  Cells:", sample1_name, "=", n_s1, ",", sample2_name, "=", n_s2))
  
  if(n_s1 < 25 || n_s2 < 25) {
    print(paste("  Skipping - insufficient cells (need ≥25 per sample)"))
    return(NULL)
  }
  
  # Get marker peaks using existing PeakMatrix
  markerPeaks <- getMarkerFeatures(
    ArchRProj = clusterSubset,
    useMatrix = "PeakMatrix",
    groupBy = "sample",
    bias = c("TSSEnrichment", "log10(nFrags)"),
    testMethod = "wilcoxon",
    useGroups = sample1_name,
    bgdGroups = sample2_name
  )
  
  # Extract results with conservative cutoff
  markerList <- getMarkers(markerPeaks, cutOff = "FDR <= 0.01 & abs(Log2FC) >= 1.25")
  
  # Save CSV if markers found
  if(sample1_name %in% names(markerList)) {
    markers <- markerList[[sample1_name]]
    if(nrow(markers) > 0) {
      filename <- paste0(sample1_name, "_vs_", sample2_name, "_", cluster_name, "_peaks.csv")
      write.csv(markers, file = filename, row.names = TRUE)
      print(paste("  Saved", nrow(markers), "significant peaks to", filename))
      
      # Create volcano plot
      create_peak_volcano(markerPeaks, sample1_name, sample2_name, cluster_name, markers)
      
      return(markers)
    }
  }
  
  print(paste("  No significant peaks found"))
  return(NULL)
}

# Function to create volcano plot for peaks
create_peak_volcano <- function(markerPeaks, s1, s2, cluster, sig_markers) {
  
  # Get all results for volcano plot
  all_results <- getMarkers(markerPeaks, cutOff = "FDR <= 1")
  
  if(s1 %in% names(all_results)) {
    volcano_data <- all_results[[s1]]
    
    if(nrow(volcano_data) > 10) {
      
      # Add significance category matching the conservative thresholds
      volcano_data$Significant <- ifelse(
        volcano_data$FDR <= 0.01 & abs(volcano_data$Log2FC) >= 1.25,
        "Significant",
        "Not Significant"
      )
      
      # Create plot
      pv <- ggplot(volcano_data, aes(x = Log2FC, y = -log10(FDR), color = Significant)) +
        geom_point(alpha = 0.6, size = 1.5) +
        scale_color_manual(values = c("Not Significant" = "grey50", "Significant" = "red")) +
        geom_hline(yintercept = -log10(0.01), linetype = "dashed", color = "blue", linewidth = 0.5) +
        geom_vline(xintercept = c(-1.25, 1.25), linetype = "dashed", color = "blue", linewidth = 0.5) +
        labs(
          title = paste0(s1, " vs ", s2, " - ", cluster, " (Peaks)"),
          x = "Log2 Fold Change",
          y = "-Log10(FDR)",
          subtitle = paste0(nrow(sig_markers), " significant peaks (FDR≤0.01, |Log2FC|≥1.25)")
        ) +
        theme_bw() +
        theme(
          legend.position = "top",
          plot.title = element_text(hjust = 0.5, face = "bold", size = 12),
          plot.subtitle = element_text(hjust = 0.5, size = 10)
        )
      
      # Save plot
      plots_dir <- paste0(getOutputDirectory(projP_3), "/Plots/")
      if(!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
      
      tryCatch({
        ggsave(
          filename = paste0(plots_dir, s1, "_vs_", s2, "_", cluster, "_Peaks_Volcano_2025-10-09.pdf"),
          plot = pv,
          width = 6,
          height = 5,
          device = "pdf"
        )
        print(paste("  Volcano plot saved for", cluster))
      }, error = function(e) {
        print(paste("  Error saving volcano plot:", e$message))
      }, finally = {
        while(dev.cur() > 1) dev.off()
      })
    }
  }
}

###############################################
## 5. RUN ALL PAIRWISE COMPARISONS (BIDIRECTIONAL)
###############################################

# Define all sample pairs (in both directions)
sample_pairs_forward <- list(
  c("sample1", "sample2"),
  c("sample1", "sample3"),
  c("sample1", "sample4"),
  c("sample2", "sample3"),
  c("sample2", "sample4"),
  c("sample3", "sample4")
)

# Create reverse pairs
sample_pairs_reverse <- lapply(sample_pairs_forward, function(x) c(x[2], x[1]))

# Combine forward and reverse
all_sample_pairs <- c(sample_pairs_forward, sample_pairs_reverse)

# Store results
all_peak_results <- list()

# Loop through all pairs (both directions) and clusters
for(pair in all_sample_pairs) {
  s1 <- pair[1]
  s2 <- pair[2]
  
  print(paste("\n=== Comparing", s1, "vs", s2, "==="))
  
  common_clusters <- get_common_clusters(s1, s2)
  print(paste("Common clusters:", paste(common_clusters, collapse=", ")))
  
  if(length(common_clusters) > 0) {
    for(cluster in common_clusters) {
      result <- compare_peaks_by_cluster(s1, s2, cluster)
      if(!is.null(result)) {
        all_peak_results[[paste(s1, s2, cluster, sep="_")]] <- result
      }
    }
  }
}

# Final cleanup
while(dev.cur() > 1) dev.off()


###############################################
## 6. COMBINE RESULTS BY CLUSTER
###############################################

print("\n=== Combining results by cluster ===")

for(cluster in all_clusters) {
  
  print(paste("Combining peak data for", cluster))
  cluster_data_list <- list()
  
  # Check all possible pairwise comparisons (both directions)
  for(pair in all_sample_pairs) {
    s1 <- pair[1]
    s2 <- pair[2]
    
    filename <- paste0(s1, "_vs_", s2, "_", cluster, "_peaks.csv")
    if(file.exists(filename)) {
      df <- read.csv(filename, row.names = 1)
      df$Comparison <- paste0(s1, "_vs_", s2)
      cluster_data_list[[paste0(s1, "_", s2)]] <- df
    }
  }
  
  # Combine if data exists
  if(length(cluster_data_list) > 0) {
    combined_df <- do.call(rbind, cluster_data_list)
    write.csv(combined_df, 
              file = paste0(cluster, "_all_peak_comparisons_combined.csv"), 
              row.names = TRUE)
    print(paste("  Combined", length(cluster_data_list), "comparisons with", 
                nrow(combined_df), "total peaks"))
  } else {
    print(paste("  No comparison files found for", cluster))
  }
}

###############################################
## 7. SUMMARY STATISTICS
###############################################

# Create summary table
summary_data <- data.frame(
  Comparison = character(),
  Cluster = character(),
  nPeaks = integer(),
  nUpregulated = integer(),
  nDownregulated = integer(),
  meanLog2FC_up = numeric(),
  meanLog2FC_down = numeric(),
  stringsAsFactors = FALSE
)

for(cluster in all_clusters) {
  for(pair in all_sample_pairs) {
    s1 <- pair[1]
    s2 <- pair[2]
    filename <- paste0(s1, "_vs_", s2, "_", cluster, "_peaks.csv")
    
    if(file.exists(filename)) {
      df <- read.csv(filename, row.names = 1)
      up_peaks <- df$Log2FC > 0
      down_peaks <- df$Log2FC < 0
      
      summary_data <- rbind(summary_data, data.frame(
        Comparison = paste0(s1, "_vs_", s2),
        Cluster = cluster,
        nPeaks = nrow(df),
        nUpregulated = sum(up_peaks),
        nDownregulated = sum(down_peaks),
        meanLog2FC_up = ifelse(sum(up_peaks) > 0, mean(df$Log2FC[up_peaks]), NA),
        meanLog2FC_down = ifelse(sum(down_peaks) > 0, mean(df$Log2FC[down_peaks]), NA)
      ))
    }
  }
}

# Save and display summary
write.csv(summary_data, "Peak_Analysis_Summary_by_Cluster_2025-10-09.csv", row.names = FALSE)
print("\n=== Summary of Differential Peaks (Bidirectional) ===")
print(head(summary_data, 20))
print(paste("\nTotal rows in summary:", nrow(summary_data)))

# Create summary visualization
if(nrow(summary_data) > 0) {
  
  # Bar plot of peak counts
  p_summary <- ggplot(summary_data, aes(x = Cluster, y = nPeaks, fill = Comparison)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(
      title = "Differential Peaks by Cluster and Comparison",
      y = "Number of Significant Peaks",
      x = "Cluster"
    ) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "right"
    ) +
    scale_fill_viridis_d()
  
  ggsave("Peak_Summary_BarPlot_by_Cluster_2025-10-09.pdf", p_summary, width = 14, height = 6)
  
  # Stacked bar plot showing up vs down
  summary_long <- summary_data %>%
    tidyr::pivot_longer(cols = c(nUpregulated, nDownregulated),
                        names_to = "Direction",
                        values_to = "Count") %>%
    mutate(Direction = ifelse(Direction == "nUpregulated", "Upregulated", "Downregulated"))
  
  p_direction <- ggplot(summary_long, aes(x = Cluster, y = Count, fill = Direction)) +
    geom_bar(stat = "identity", position = "stack") +
    facet_wrap(~Comparison, ncol = 3) +
    labs(
      title = "Direction of Peak Changes by Cluster",
      y = "Number of Peaks",
      x = "Cluster"
    ) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("Upregulated" = "#D62728", "Downregulated" = "#1F77B4"))
  
  ggsave("Peak_Direction_by_Cluster_2025-10-09.pdf", p_direction, width = 16, height = 10)
}

# Clusters with most differential peaks
if(nrow(summary_data) > 0) {
  top_clusters <- summary_data %>%
    group_by(Cluster) %>%
    summarise(TotalPeaks = sum(nPeaks)) %>%
    arrange(desc(TotalPeaks))
  
  print("\n=== Clusters with Most Differential Peaks ===")
  print(top_clusters)
  write.csv(top_clusters, "Top_Clusters_by_Peak_Count_2025-10-09.csv", row.names = FALSE)
}


#Cluster TotalPeaks
#<chr>        <int>
# 1 C18          11363
#2 C15           4777
#3 C1            2075
#4 C11            477
#5 C2             397
#6 C20            233
#7 C19            227
#8 C16            186
#9 C8               2
#10 C10              1
#11 C21              1
#12 C6               1
#13 C9               1


###############################################
## 8. PEAK HEATMAPS BY CLUSTER
###############################################

library(ArchR)
library(ggplot2)
library(dplyr)
library(pheatmap)
library(viridis)


###############################################
## 8. SIMPLIFIED PEAK HEATMAPS BY CLUSTER
###############################################

library(ggplot2)
library(dplyr)
library(viridis)

create_peak_heatmap <- function(cluster_name, min_peaks = 20) {
  
  combined_file <- paste0(cluster_name, "_all_peak_comparisons_combined.csv")
  if(!file.exists(combined_file)) {
    print(paste("No combined file found for", cluster_name))
    return(NULL)
  }
  
  df <- read.csv(combined_file, row.names = 1)
  if(nrow(df) < min_peaks) {
    print(paste("Insufficient peaks for", cluster_name, "- only", nrow(df)))
    return(NULL)
  }
  
  print(paste("Creating heatmap for", cluster_name, "with", nrow(df), "peaks"))
  
  # Get top peaks by FDR
  top_peaks <- df %>%
    arrange(FDR) %>%
    head(50)
  
  # Create peak identifier with gene name if available
  if("nearestGene" %in% colnames(top_peaks)) {
    top_peaks$peak_label <- paste0(top_peaks$nearestGene, " (", 
                                   top_peaks$seqnames, ":", 
                                   top_peaks$start, "-", 
                                   top_peaks$end, ")")
  } else {
    top_peaks$peak_label <- paste0(top_peaks$seqnames, ":", 
                                   top_peaks$start, "-", 
                                   top_peaks$end)
  }
  
  # Create matrix using ggplot2 instead
  peak_data_long <- top_peaks %>%
    select(peak_label, Comparison, Log2FC) %>%
    group_by(peak_label, Comparison) %>%
    summarise(Log2FC = mean(Log2FC, na.rm = TRUE), .groups = 'drop')
  
  # Order peaks by their mean Log2FC for better visualization
  peak_order <- peak_data_long %>%
    group_by(peak_label) %>%
    summarise(mean_fc = mean(abs(Log2FC)), .groups = 'drop') %>%
    arrange(desc(mean_fc)) %>%
    pull(peak_label)
  
  peak_data_long$peak_label <- factor(peak_data_long$peak_label, levels = rev(peak_order))
  
  # Save matrix in long format
  write.csv(peak_data_long, 
            paste0(cluster_name, "_top50_peaks_data.csv"),
            row.names = FALSE)
  
  # Create heatmap using ggplot2 with borders and labels
  pdf_file <- paste0(cluster_name, "_top50_peaks_heatmap.pdf")
  
  tryCatch({
    p <- ggplot(peak_data_long, aes(x = Comparison, y = peak_label, fill = Log2FC)) +
      geom_tile(color = "gray30", linewidth = 0.2) +  # Thin gray grid lines
      scale_fill_gradient2(low = "darkblue", mid = "white", high = "darkred", 
                           midpoint = 0, limits = c(-2, 2), oob = scales::squish,
                           name = "Log2FC") +
      labs(title = paste0(cluster_name, " - Top 50 Differential Peaks"),
           x = "Comparison", y = "Peak (Gene)") +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 6, hjust = 1),  # Show peak labels
        axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.title = element_text(size = 10, face = "bold"),
        plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
        panel.grid = element_blank(),
        panel.background = element_rect(fill = "white"),
        legend.position = "right"
      )
    
    ggsave(pdf_file, plot = p, width = 12, height = 14, device = "pdf")
    print(paste("  ✓ Heatmap saved:", pdf_file))
    
  }, error = function(e) {
    print(paste("  ✗ Heatmap error:", e$message))
    if(file.exists(pdf_file)) file.remove(pdf_file)
  })
  
  return(top_peaks)
}

# Generate heatmaps
for(cluster in all_clusters) {
  create_peak_heatmap(cluster, min_peaks = 20)
}


################################################# 
# IDENTIFY RECIPROCAL PEAKS (Peaks significant in BOTH comparison directions)
#################################################

identify_reciprocal_peaks <- function(cluster_name) {
  print(paste("\n=== Finding Reciprocal Peaks for", cluster_name, "==="))
  
  combined_file <- paste0(cluster_name, "_all_peak_comparisons_combined.csv")
  if(!file.exists(combined_file)) {
    print(paste("  No data for", cluster_name))
    return(NULL)
  }
  
  df <- read.csv(combined_file, row.names = 1)
  if(nrow(df) == 0 || !"Comparison" %in% colnames(df)) return(NULL)
  
  # Parse comparison to get sample pairs
  df$sample1 <- sapply(strsplit(df$Comparison, "_vs_"), `[`, 1)
  df$sample2 <- sapply(strsplit(df$Comparison, "_vs_"), `[`, 2)
  
  # Get gene names for annotation (handle different possible column names)
  gene_col <- NULL
  possible_gene_cols <- c("nearestGene", "NearestGene", "gene", "Gene", "symbol")
  for(col in possible_gene_cols) {
    if(col %in% colnames(df)) {
      gene_col <- col
      break
    }
  }
  
  if(is.null(gene_col)) {
    print(paste("  Warning: No gene annotation column found for", cluster_name))
    return(NULL)
  }
  
  # Find reciprocal peaks for each sample pair
  reciprocal_results <- list()
  
  # Get all unique sample pairs (unordered)
  all_comparisons <- unique(df$Comparison)
  sample_pairs <- unique(data.frame(
    s1 = df$sample1,
    s2 = df$sample2,
    stringsAsFactors = FALSE
  ))
  
  # Create pair identifier
  sample_pairs$pair_id <- apply(sample_pairs, 1, function(x) {
    paste(sort(c(x[1], x[2])), collapse = "_")
  })
  
  unique_pair_ids <- unique(sample_pairs$pair_id)
  
  for(pair_id in unique_pair_ids) {
    # Get the two samples
    samples <- strsplit(pair_id, "_")[[1]]
    if(length(samples) != 2) next
    
    s1 <- samples[1]
    s2 <- samples[2]
    
    # Get peaks from both directions
    forward_comp <- paste0(s1, "_vs_", s2)
    reverse_comp <- paste0(s2, "_vs_", s1)
    
    # Create unique peak identifiers based on genomic coordinates
    df$peak_id <- paste(df$seqnames, df$start, df$end, sep = "_")
    
    peaks_forward <- df[df$Comparison == forward_comp, ]
    peaks_reverse <- df[df$Comparison == reverse_comp, ]
    
    if(nrow(peaks_forward) == 0 || nrow(peaks_reverse) == 0) next
    
    # Find RECIPROCAL peaks (same genomic coordinates in BOTH directions)
    reciprocal_peak_ids <- intersect(peaks_forward$peak_id, peaks_reverse$peak_id)
    
    if(length(reciprocal_peak_ids) > 0) {
      print(paste("  Found", length(reciprocal_peak_ids), "reciprocal peaks for", s1, "vs", s2))
      print(paste("    (", nrow(peaks_forward), "peaks in", forward_comp, ",", 
                  nrow(peaks_reverse), "peaks in", reverse_comp, ")"))
      
      # Get detailed info for reciprocal peaks
      forward_data <- peaks_forward[peaks_forward$peak_id %in% reciprocal_peak_ids, ]
      reverse_data <- peaks_reverse[peaks_reverse$peak_id %in% reciprocal_peak_ids, ]
      
      # Merge data for reciprocal peaks
      reciprocal_df <- merge(
        forward_data[, c("peak_id", "seqnames", "start", "end", gene_col, "Log2FC", "FDR")],
        reverse_data[, c("peak_id", "Log2FC", "FDR")],
        by = "peak_id",
        suffixes = c(paste0("_", forward_comp), paste0("_", reverse_comp))
      )
      
      # Rename for clarity
      colnames(reciprocal_df)[colnames(reciprocal_df) == gene_col] <- "nearestGene"
      reciprocal_df$comparison_pair <- pair_id
      reciprocal_df$cluster <- cluster_name
      
      # IMPROVED DIRECTIONALITY METRICS
      fc_forward <- reciprocal_df[[paste0("Log2FC_", forward_comp)]]
      fc_reverse <- reciprocal_df[[paste0("Log2FC_", reverse_comp)]]
      fdr_forward <- reciprocal_df[[paste0("FDR_", forward_comp)]]
      fdr_reverse <- reciprocal_df[[paste0("FDR_", reverse_comp)]]
      
      # 1. Biological concordance (expected: opposite signs = same biological change)
      reciprocal_df$biologically_concordant <- (fc_forward * fc_reverse) < 0
      
      # 2. Effect size consistency (magnitudes should be similar)
      reciprocal_df$fc_ratio <- abs(fc_forward) / abs(fc_reverse)
      reciprocal_df$fc_magnitude_consistent <- (reciprocal_df$fc_ratio > 0.5 & reciprocal_df$fc_ratio < 2.0)
      
      # 3. Statistical robustness (both significant)
      reciprocal_df$both_highly_significant <- (fdr_forward < 0.01) & (fdr_reverse < 0.01)
      reciprocal_df$mean_FDR <- (fdr_forward + fdr_reverse) / 2
      reciprocal_df$mean_absLog2FC <- (abs(fc_forward) + abs(fc_reverse)) / 2
      
      # 4. Overall quality score
      reciprocal_df$robust_reciprocal <- reciprocal_df$biologically_concordant & 
        reciprocal_df$fc_magnitude_consistent & 
        reciprocal_df$both_highly_significant
      
      # 5. Which sample has higher accessibility at this peak
      reciprocal_df$higher_accessibility_in <- ifelse(
        fc_forward > 0, 
        s1,  # positive Log2FC in forward means s1 > s2
        s2   # negative Log2FC in forward means s2 > s1
      )
      
      # 6. Flag potential issues
      reciprocal_df$potential_issue <- !reciprocal_df$biologically_concordant | !reciprocal_df$fc_magnitude_consistent
      
      # Add interpretable labels
      reciprocal_df$interpretation <- ifelse(
        reciprocal_df$robust_reciprocal,
        paste0("Robust: Peak more accessible in ", reciprocal_df$higher_accessibility_in, 
               " (vs ", ifelse(reciprocal_df$higher_accessibility_in == s1, s2, s1), ")"),
        ifelse(
          !reciprocal_df$biologically_concordant,
          "WARNING: Contradictory directions",
          ifelse(
            !reciprocal_df$fc_magnitude_consistent,
            "WARNING: Inconsistent effect sizes",
            "Moderate confidence"
          )
        )
      )
      
      # Reorder columns for clarity
      col_order <- c("peak_id", "seqnames", "start", "end", "nearestGene",
                     "cluster", "comparison_pair", "higher_accessibility_in",
                     paste0("Log2FC_", forward_comp), paste0("FDR_", forward_comp),
                     paste0("Log2FC_", reverse_comp), paste0("FDR_", reverse_comp),
                     "mean_FDR", "mean_absLog2FC", "fc_ratio",
                     "biologically_concordant", "fc_magnitude_consistent", 
                     "both_highly_significant", "robust_reciprocal",
                     "potential_issue", "interpretation")
      
      reciprocal_df <- reciprocal_df[, col_order[col_order %in% colnames(reciprocal_df)]]
      
      # Save results
      filename <- paste0(cluster_name, "_RECIPROCAL_PEAKS_", s1, "_vs_", s2, ".csv")
      write.csv(reciprocal_df, filename, row.names = FALSE)
      
      reciprocal_results[[pair_id]] <- reciprocal_df
    } else {
      print(paste("  No reciprocal peaks for", s1, "vs", s2))
    }
  }
  
  # Combine all reciprocal results for this cluster
  if(length(reciprocal_results) > 0) {
    all_reciprocal <- do.call(rbind, reciprocal_results)
    write.csv(all_reciprocal, 
              paste0(cluster_name, "_ALL_RECIPROCAL_PEAKS.csv"),
              row.names = FALSE)
    
    print(paste("  ✓ Total reciprocal peaks in", cluster_name, ":", nrow(all_reciprocal)))
    return(all_reciprocal)
  }
  
  return(NULL)
}

# Run reciprocal peak analysis for all clusters
all_reciprocal_peak_results <- list()
for(cluster in all_clusters) {
  result <- identify_reciprocal_peaks(cluster)
  if(!is.null(result)) {
    all_reciprocal_peak_results[[cluster]] <- result
  }
}

# Create master summary of reciprocal peaks
if(length(all_reciprocal_peak_results) > 0) {
  master_reciprocal_peaks <- do.call(rbind, all_reciprocal_peak_results)
  write.csv(master_reciprocal_peaks, 
            "MASTER_ALL_RECIPROCAL_PEAKS_ALL_CLUSTERS.csv",
            row.names = FALSE)
  
  print("\n=== RECIPROCAL PEAK SUMMARY ===")
  print(paste("Total reciprocal peaks across all clusters:", nrow(master_reciprocal_peaks)))
  
  # Summary statistics by cluster and comparison
  reciprocal_summary <- master_reciprocal_peaks %>%
    group_by(cluster, comparison_pair) %>%
    summarise(
      n_reciprocal_peaks = n(),
      n_robust_peaks = sum(robust_reciprocal, na.rm = TRUE),
      pct_robust = round(100 * n_robust_peaks / n(), 1),
      mean_FDR = round(mean(mean_FDR, na.rm = TRUE), 4),
      mean_absLog2FC = round(mean(mean_absLog2FC, na.rm = TRUE), 2),
      min_FDR = round(min(mean_FDR, na.rm = TRUE), 4),
      max_absLog2FC = round(max(mean_absLog2FC, na.rm = TRUE), 2),
      top_genes = paste(head(nearestGene[order(mean_FDR)], 5), collapse = ";"),
      .groups = 'drop'
    ) %>%
    arrange(cluster, comparison_pair)
  
  write.csv(reciprocal_summary, "Reciprocal_Peak_Summary_by_Cluster.csv", row.names = FALSE)
  
  print("\nReciprocal peaks by cluster and comparison:")
  print(reciprocal_summary)
  
  # Summary by cluster only
  cluster_summary <- master_reciprocal_peaks %>%
    group_by(cluster) %>%
    summarise(
      n_reciprocal_peaks = n(),
      n_robust_peaks = sum(robust_reciprocal, na.rm = TRUE),
      pct_robust = round(100 * n_robust_peaks / n(), 1),
      n_comparisons = length(unique(comparison_pair)),
      unique_peaks = length(unique(peak_id)),
      unique_genes = length(unique(nearestGene)),
      mean_FDR = round(mean(mean_FDR, na.rm = TRUE), 4),
      mean_absLog2FC = round(mean(mean_absLog2FC, na.rm = TRUE), 2),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_reciprocal_peaks))
  
  write.csv(cluster_summary, "Reciprocal_Peak_Summary_by_Cluster_Only.csv", row.names = FALSE)
  
  print("\nReciprocal peaks by cluster:")
  print(cluster_summary)
  
  # Visualization of reciprocal peaks
  p_reciprocal <- ggplot(reciprocal_summary, aes(x = cluster, y = n_reciprocal_peaks, fill = comparison_pair)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(
      title = "Reciprocal Peaks by Cluster",
      subtitle = "Peaks significant in BOTH directions of comparison (same genomic coordinates)",
      y = "Number of Reciprocal Peaks",
      x = "Cluster",
      fill = "Comparison"
    ) +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "right"
    ) +
    scale_fill_viridis_d()
  
  ggsave("Reciprocal_Peaks_by_Cluster_Barplot.pdf", p_reciprocal, width = 14, height = 7)
  
  # Plot effect sizes
  p_effect <- ggplot(master_reciprocal_peaks, aes(x = cluster, y = mean_absLog2FC, fill = comparison_pair)) +
    geom_boxplot() +
    labs(
      title = "Effect Sizes of Reciprocal Peaks",
      subtitle = "Mean absolute Log2FC across both comparison directions",
      y = "Mean |Log2FC|",
      x = "Cluster",
      fill = "Comparison"
    ) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_viridis_d()
  
  ggsave("Reciprocal_Peak_Effect_Sizes.pdf", p_effect, width = 14, height = 7)
  
  # Create a peak-level summary (which peaks appear most often)
  peak_frequency <- master_reciprocal_peaks %>%
    group_by(peak_id, seqnames, start, end, nearestGene) %>%
    summarise(
      n_occurrences = n(),
      clusters = paste(unique(cluster), collapse = ";"),
      comparisons = paste(unique(comparison_pair), collapse = ";"),
      mean_FDR = round(mean(mean_FDR, na.rm = TRUE), 4),
      mean_absLog2FC = round(mean(mean_absLog2FC, na.rm = TRUE), 2),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_occurrences))
  
  write.csv(peak_frequency, "Peak_Frequency_Across_Reciprocal_Sets.csv", row.names = FALSE)
  
  print("\nMost frequent peaks across all reciprocal sets:")
  print(head(peak_frequency, 30))
  
  # Summary of genes near reciprocal peaks
  gene_summary <- master_reciprocal_peaks %>%
    group_by(nearestGene) %>%
    summarise(
      n_reciprocal_peaks_nearby = n(),
      n_clusters = length(unique(cluster)),
      clusters = paste(unique(cluster), collapse = ";"),
      mean_FDR = round(mean(mean_FDR, na.rm = TRUE), 4),
      mean_absLog2FC = round(mean(mean_absLog2FC, na.rm = TRUE), 2),
      .groups = 'drop'
    ) %>%
    arrange(desc(n_reciprocal_peaks_nearby))
  
  write.csv(gene_summary, "Genes_Near_Reciprocal_Peaks_Summary.csv", row.names = FALSE)
  
  print("\nGenes with most nearby reciprocal peaks:")
  print(head(gene_summary, 30))
}


################################################# 
# EXPORT PEAK COORDINATES FOR IGV/UCSC
################################################

# Export significant peaks in BED format for genome browser visualization
export_peaks_to_bed <- function(cluster_name) {
  
  combined_file <- paste0(cluster_name, "_all_peak_comparisons_combined.csv")
  if(!file.exists(combined_file)) return(NULL)
  
  df <- read.csv(combined_file, row.names = 1)
  if(nrow(df) == 0) return(NULL)
  
  # Create BED file
  bed_df <- data.frame(
    chrom = df$seqnames,
    chromStart = df$start,
    chromEnd = df$end,
    name = paste0(cluster_name, "_peak_", 1:nrow(df)),
    score = -log10(df$FDR),  # Use -log10(FDR) as score
    strand = "."
  )
  
  bed_file <- paste0(cluster_name, "_differential_peaks.bed")
  write.table(bed_df, bed_file, sep = "\t", quote = FALSE, 
              row.names = FALSE, col.names = FALSE)
  
  print(paste("Exported", nrow(bed_df), "peaks to", bed_file))
}

# Export BED files for all clusters
for(cluster in all_clusters) {
  export_peaks_to_bed(cluster)
}

################################################# 
# SAVE PROJECT
################################################

saveArchRProject(ArchRProj = projP_3, 
                 outputDirectory = "/Volumes/DataBox2/Save-ProjP_3",
                 load = FALSE)

