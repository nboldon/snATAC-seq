


module load miniconda3/24.3.0
conda activate cellranger_atac


###############################################


R

# Load libraries
library(ArchR)
library(Seurat)
library(BiocManager)
library(BiocGenerics)
library(clusterProfiler)  
library(org.Mm.eg.db) #For mouse genomes
library(AnnotationDbi)
library(enrichplot)
library(pheatmap)
library(BSgenome.Mmusculus.UCSC.mm10)

set.seed(1)

setwd("/project/eon/Protocol_Paper/cellRangerATAC_protocol_paper/archR_analysis")
addArchRGenome("mm10")
addArchRThreads(threads=1)


###############################################


#Load project
projP_2 <- loadArchRProject(path = "/project/eon/Protocol_Paper/Save-ProjP_2", force = FALSE, showLogo = FALSE)

#numberOfCells(1): 23379
#medianTSS(1): 14.263
#medianFrags(1): 22977

getAvailableMatrices(projP_2)


###############################################


# Check fragment information across samples
cellData <- getCellColData(projP_2)
print(table(cellData$Sample))  # Check sample distribution

#cortex_fresh_v1 cortex_v1-1_chromx   cortex_v2_chromx     cortex_v2_cont 
#              4052               6230               6713               6384 


# Look for samples with very low fragment counts
print(summary(cellData$nFrags))

#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   1001   13076   22956   23933   32856   99055 


###############################################


bash

conda install -c bioconda macs2

# Verify installation
which macs
# ~/.conda/envs/cellranger_atac/bin/macs2
macs2 --version


########################


R

# Install the mouse mm10 BSgenome package
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install("BSgenome.Mmusculus.UCSC.mm10")

# Load the package
library(BSgenome.Mmusculus.UCSC.mm10)

# Check current genome
getGenome(projP_2)

# If needed, reset the genome
addArchRGenome("mm10")


###############################################


R

## Pseudo-bulk replicates in ArchR

projP_3 <- addGroupCoverages(ArchRProj = projP_2, groupBy = "Clusters") 


#################


# Check that GroupCoverages directory exists
list.files(getOutputDirectory(projP_3))  # Should see "GroupCoverages" folder

# Check contents of GroupCoverages
list.files(file.path(getOutputDirectory(projP_3), "GroupCoverages"))

# Check number of cells per cluster/cell type
cellsPerGroup <- table(projP_3$Clusters)  # or proj$YourCellTypeColumn
print(cellsPerGroup)

# Visualize
barplot(cellsPerGroup, las = 2, main = "Cells per Cluster",
        ylab = "Number of Cells", col = "steelblue")
abline(h = 100, col = "red", lty = 2)  # Recommended minimum

# Check fragment depth per cell type
p1 <- plotGroups(
    ArchRProj = projP_3,
    groupBy = "Clusters",
    colorBy = "cellColData",
    name = "nFrags",
    plotAs = "violin"
)
p1

# Calculate total fragments per pseudo-bulk
cellData <- getCellColData(projP_3, select = c("Clusters", "nFrags"))
cellData <- as.data.frame(cellData)

fragmentDepth <- aggregate(nFrags ~ Clusters, data = cellData, FUN = sum)
print(fragmentDepth)

# Check if adequate
fragmentDepth$adequate <- fragmentDepth$nFrags >= 25e6
print(fragmentDepth)


# Check TSS enrichment by cluster (signal quality)
p2 <- plotGroups(
    ArchRProj = projP_3,
    groupBy = "Clusters",
    colorBy = "cellColData", 
    name = "TSSEnrichment",
    plotAs = "violin"
)
p2

# Visualize fragment depth per cluster
ggplot(fragmentDepth, aes(x = Clusters, y = nFrags/1e6, fill = adequate)) +
    geom_bar(stat = "identity") +
    geom_hline(yintercept = 25, linetype = "dashed", color = "red") +
    labs(y = "Total Fragments (millions)", 
         title = "Fragment Depth per Pseudo-bulk",
         subtitle = "Red line = 25M minimum recommended") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = c("TRUE" = "darkgreen", "FALSE" = "darkred"))


###############################################


# Calling Peaks w/ Macs2


pathToMacs2 <- "/home/nboldon/.conda/envs/cellranger_atac/bin/macs2"
## Test if the path works
#system(paste(pathToMacs2, "--version")) 
#pathToMacs2 <- findMacs2()

projP_3 <- addReproduciblePeakSet(
    ArchRProj = projP_3, 
    groupBy = "Clusters", 
    pathToMacs2 = pathToMacs2
)


#    Group nCells nCellsUsed nReplicates nMin nMax maxPeaks
# C1     C1   1236       1236           4  227  368   150000
# C2     C2   2582       1944           4  444  500   150000
# C3     C3    811        811           4  116  238   150000
# C4     C4     62         58           2   40   40    29000
# C5     C5    129        129           2   40   89    64500
# C6     C6    518        518           4   81  175   150000
# C7     C7    770        770           4  147  226   150000
# C8     C8    328        328           4   59   96   150000
# C9     C9    518        518           4   83  164   150000
# C10   C10    273        273           4   41   84   136500
# C11   C11   2196       1872           4  372  500   150000
# C12   C12    447        447           4   80  137   150000
# C13   C13    139        139           2   69   70    69500
# C14   C14    260        251           3   75   95   125500
# C15   C15   1733       1733           4  397  452   150000
# C16   C16   1979       1792           4  292  500   150000
# C17   C17    161        161           3   43   72    80500
# C18   C18   4191       2000           4  500  500   150000
# C19   C19   2057       1834           4  334  500   150000
# C20   C20   2026       1805           4  305  500   150000
# C21   C21    416        416           4   68  124   150000
# C22   C22    147        147           2   51   96    73500
# C23   C23    400        400           4   93  105   150000



####################3


getPeakSet(projP_3)


projP_3 <- addPeakMatrix(projP_3)


#Verify matrices in project
getAvailableMatrices(projP_3)


saveArchRProject(ArchRProj = projP_3, outputDirectory = "/project/eon/Protocol_Paper/Save-ProjP_3", load = FALSE)


###############################################


# Identify marker peaks and account for differences in data quality amongst cell groups
markersPeaks <- getMarkerFeatures(
    ArchRProj = projP_3,
    useMatrix = "PeakMatrix",
    groupBy = "Clusters",
  bias = c("TSSEnrichment", "log10(nFrags)"),
  testMethod = "wilcoxon"
)


# To retrieve particular slices of the SummarizedExperiment; returns a list of DataFrame objects, one for each cell group
markerList <- getMarkers(markersPeaks, cutOff = "FDR <= 0.01 & abs(Log2FC) >= 1.25")
markerList

# Save markerList as a .csv file locally
write.csv(markerList, file = "/project/eon//Protocol_Paper/cellRangerATAC_protocol_paper/archR_analysis/Peak_markerList_conservative.csv", row.names = FALSE)


#######

markerList <- getMarkers(markersPeaks, cutOff = "FDR <= 0.1 & abs(Log2FC) >= 0.5")
markerList

# Save markerList as a .csv file locally
write.csv(markerList, file = "/project/eon//Protocol_Paper/cellRangerATAC_protocol_paper/archR_analysis/Peak_markerList_expanded.csv", row.names = FALSE)


###############################################

heatmapPeaks <- plotMarkerHeatmap(
  seMarker = markersPeaks, 
  cutOff = "FDR <= 0.1 & abs(Log2FC) >= 0.5",
  transpose = TRUE
)

draw(heatmapPeaks, heatmap_legend_side = "bot", annotation_legend_side = "bot")

plotPDF(heatmapPeaks, name = "Peak-Marker-Heatmap_2025-09-22", width = 8, height = 6, ArchRProj = projP_3, addDOC = FALSE)


###############################################
###############################################
###############################################


# Add motif annotations

projP_3 <- addMotifAnnotations(ArchRProj = projP_3, motifSet = "cisbp", name = "Motif")


###############################################


# Motif enrichment in marker peaks

enrichMotifs <- peakAnnoEnrichment(
    seMarker = markersPeaks,
    ArchRProj = projP_3,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & abs(Log2FC) >= 0.5"
  )

enrichMotifs

heatmapEM <- plotEnrichHeatmap(enrichMotifs, n = 7, transpose = TRUE)

ComplexHeatmap::draw(heatmapEM, heatmap_legend_side = "bot", annotation_legend_side = "bot")

plotPDF(heatmapEM, name = "Motifs-Enriched-Marker-Heatmap_2025-09-22", width = 8, height = 6, ArchRProj = projP_3, addDOC = FALSE)


############################################
############################################


############################################
############################################


## Motif Deviations


# First check to make sure we've added motif annotations to the ArchRProject

if("Motif" %ni% names(projP_3@peakAnnotation)){c
    projP_3 <- addMotifAnnotations(ArchRProj = projP_3, motifSet = "cisbp", name = "Motif")
}


# We also need to add a set of background peaks which are used in computing deviations. 
# Background peaks are chosen using the chromVAR::getBackgroundPeaks() function which samples peaks based on similarity in GC-content and number of fragments across all samples using the Mahalanobis distance.

projP_3 <- addBgdPeaks(projP_3)


# We are now ready to compute per-cell deviations accross all of our motif annotations using the addDeviationsMatrix() function. This function has an optional parameter called matrixName that allows us to define the name of the deviations matrix that will be stored in the Arrow files. 
# If we do not provide a value to this parameter, as in the example below, this function creates a matrix name by adding the word “Matrix” to the name of the peakAnnotation. 
# The example below creates a deviations matrix in each of our Arrow files called “MotifMatrix”.

projP_3 <- addDeviationsMatrix(
  ArchRProj = projP_3, 
  peakAnnotation = "Motif",
  force = TRUE
)


# To access these deviations, we use the getVarDeviations() function. 
# If we want this function to return a ggplot object, we set plot = TRUE otherwise, this function would return the DataFrame object. 
# The head of that DataFrame object is displayed by default when the function is run.

plotVarDev <- getVarDeviations(projP_3, name = "MotifMatrix", plot = TRUE)


# Plot variable deviations
plotVarDev


# Save plot
plotPDF(plotVarDev, name = "Variable-Motif-Deviation-Scores_2025-09-22", width = 5, height = 5, ArchRProj = projP_3, addDOC = FALSE)


############################################
############################################


saveArchRProject(ArchRProj = projP_3, outputDirectory = "/project/eon/Protocol_Paper/Save-ProjP_3", load = FALSE)


###############################################
###############################################
###############################################


