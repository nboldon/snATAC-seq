
module load miniconda3/24.3.0
conda activate cellranger_atac

###############################################


R

# Load libraries
library(ArchR)
library(Seurat)
library(BiocManager)
library(BiocGenerics)
library(clusterProfiler)  
library(org.Mm.eg.db) #For mouse genomes
library(AnnotationDbi)
library(enrichplot)
library(pheatmap)

set.seed(1)

addArchRGenome("mm10")
addArchRThreads(threads=8)


###############################################


## Create Arrow Files


# Set working directory 
setwd("/project/eon/Protocol_Paper/cellRangerATAC_protocol_paper/archR_analysis")

# Define input fragment files
inputFiles <- c(
  "../fragments_for_analysis/adult_brain_5k_v1_fragments.tsv.gz",
  "../fragments_for_analysis/cortex_8k_v1-1_fragments.tsv.gz", 
  "../fragments_for_analysis/cortex_8k_v2_chromiumx_fragments.tsv.gz",
  "../fragments_for_analysis/cortex_8k_v2_controller_fragments.tsv.gz"
)

# Define sample names
sampleNames <- c(
  "cortex_fresh_v1",
  "cortex_v1-1_chromx",
  "cortex_v2_chromx", 
  "cortex_v2_cont"
)

# Create Arrow files
ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles,
  sampleNames = sampleNames,
  outputNames = sampleNames,
  minTSS = 7,              # Minimum TSS enrichment score
  minFrags = 1000,         # Minimum fragments per cell
  addTileMat = TRUE,       # Add tile matrix for peak calling
  addGeneScoreMat = TRUE,  # Add gene score matrix
  bcTag= 'CB',
  force = TRUE             # Overwrite existing files
)

# Print Arrow file paths
print(ArrowFiles)



###############################################


arrowFiles <- c(
  "archR_analysis/cortex_fresh_v1.arrow",
  "archR_analysis/cortex_v1-1_chromx.arrow", 
  "archR_analysis/cortex_v2_chromx.arrow",
  "archR_analysis/cortex_v2_cont.arrow"
)
arrowFiles
file.exists(arrowFiles)


projProtocol_1 <- ArchRProject (
	ArrowFiles=arrowFiles,
	outputDirectory="archr_analysis",
	copyArrows=FALSE,
	showLogo=FALSE
)


projProtocol_1
numberOfCells(1): 24995
medianTSS(1): 14.207
medianFrags(1): 23530


###############################################


## Infer snATAC-seq doublets with ArchR

projP_1 <- addDoubletScores(
	input=projProtocol_1,
	k=10,
	knnMethod="UMAP",
	LSIMethod=1
)

projP_1
#numberOfCells(1): 24995
#medianTSS(1): 14.207
#medianFrags(1): 23530

getAvailableMatrices(projP_1)
#"GeneScoreMatrix" "TileMatrix"  

quantile(projP_1$TSSEnrichment)
# 0%     25%     50%     75%    100% 
# 7.0000 11.4420 14.2070 18.4945 65.4460 


df <- getCellColData(projP_1,
	select=c("log10(nFrags)",
	"TSSEnrichment"))
df



###############################################


p <- ggPoint(
	x=df[,1],
	y=df[,2],
	colorDensity=TRUE,
	continuousSet="sambaNight",
	xlabel="Log10 Unique Fragments",
	ylabel="TSS Enrichment",
	xlim=c(log10(500), quantile(df[,1], probs=0.99)),
	ylim=c(0, quantile(df[,2], probs=0.99))
)	
#+ geom_hline(yintercept=4, lty="dashed",
#+ geom_vline(xintercept=3, Ity="dashed")

plotPDF(
	p, name="Protocol 1 - TSS Enrichment vs. Unique Fragments",
	ArchRProj=projP_1,
	addDOC=FALSE
)


###############################################



cellData <- getCellColData(projP_1)
print(colnames(cellData))




## Ridge plot for each sample for the TSS Enrichment scores


p1 <- plotGroups(
	ArchRProj=projP_1,
	groupBy="Sample",
	colorBy="cellColData",
	name="TSSEnrichment",
	plotAs="ridges"
)


p2 <- plotGroups(
        ArchRProj=projP_1,
        groupBy="Sample",
        colorBy="cellColData",
        name="TSSEnrichment",
        plotAs="violin",
	alpha=0.4,
	addBoxPlot=TRUE
)


p3 <- plotGroups(
        ArchRProj=projP_1,
        groupBy="Sample",
        colorBy="cellColData",
        name="log10(nFrags)",
        plotAs="ridges"
)


p4 <- plotGroups(
        ArchRProj=projP_1,
        groupBy="Sample",
        colorBy="cellColData",
        name="log10(nFrags)",
        plotAs="violin",
        alpha=0.4,
        addBoxPlot=TRUE
)


plotPDF(p1,p2,p3,p4,
	name="projP_1_QualityControl.pdf",
	ArchRProj=projP_1,
	addDOC=FALSE,
	width=4, height=4
)



## Fragment size distribution plot

p5 <- plotFragmentSizes(
	ArchRProj=projP_1,
)

plotPDF(p5,
	name="projP_1_QC_FragSizes.pdf",
	ArchRProj=projP_1,
	addDOC=FALSE,
	width=5, height=5
)


#####################################################


## Save projP_1

saveArchRProject(
	ArchRProj=projP_1,
	outputDirectory="./",
	load=FALSE
)



#####################################################


## Create projP_2

projP_1 <- loadArchRProject(path="_")


## Filtering Doublets

projP_2 <- filterDoublets(projP_1)

#Filtering 1616 cells from ArchRProject!
#	cortex_fresh_v1 : 179 of 4231 (4.2%)
#	cortex_v1-1_chromx : 445 of 6675 (6.7%)
#	cortex_v2_chromx : 523 of 7236 (7.2%)
#	cortex_v2_cont : 469 of 6853 (6.8%)


projP_2
#numberOfCells(1): 23379
#medianTSS(1): 14.263
#medianFrags(1): 22977


#####################################################


## Dimensionality Reduction using Iterative LSI
# Creates a reducedDims object called "IterativeLSI"


projP_2 <- addIterativeLSI(
	ArchRProj=projP_2,
	useMatrix="TileMatrix",
	name="IterativeLSI",
	iterations=2,
	clusterParams=list (
	resolution=c(0.2),
	sampleCells=10000,
	n.start=10
	),
	varFeatures=25000,
	dimsToUse=1:30
	)
#Resulted in errors- did not run


## Reduce parallel processing and memory load to remedy errors, for ex:

# Clear memory and reduce threading
gc()
addArchRThreads(threads = 1)  # Use single thread

# Try with reduced parameters to minimize file I/O
projP_2 <- addIterativeLSI(
  ArchRProj = projP_2,
  useMatrix = "TileMatrix", 
  name = "IterativeLSI",
  iterations = 2,              # Reduce to 1 iteration to test
  clusterParams = list(
    resolution = c(0.2),
    sampleCells = 10000,        # Reduce sample size if needed
    n.start = 10
  ),
  varFeatures = 15000,         # Reduce number of features
  dimsToUse = 1:20,            # Reduce dimensions
  force = TRUE
)



#####################################################


## In addition to Iterative LSI for batch corrections,
# Harmony can also be used as a batch correction tool. 


projP_2 <- addHarmony(
	ArchRProj=projP_2,
	reducedDims="IterativeLSI",
	name="Harmony",
	groupBy="Sample"
)



#####################################################


## Clustering using Seurat's FindClusters() function


projP_2 <- addClusters(
	input=projP_2,
	reducedDims="IterativeLSI",
	method="Seurat",
	name="Clusters",
	resolution=0.8
)

head(projP_2$Clusters)
table(projP_2$Clusters)


#  C1  C10  C11  C12  C13  C14  C15  C16  C17  C18  C19   C2  C20   C3   C4   C5 
# 199 3154  127  264  449 2211  871 1305 1146 2581  143 1027  404  129 1299  308 
#  C6   C7   C8   C9 
# 504  653 4236 2369 


#####################################################


## Uniform Manifold Appreciation Maps (UMAPs)


projP_2 <- addUMAP(
	ArchRProj=projP_2,
	reducedDims="IterativeLSI",
	name="UMAP",
	nNeighbors=30,
	minDist=0.5,
	metric="cosine"
)


################


## To color UMAP by sample


p1 <- plotEmbedding(
	ArchRProj=projP_2,
	colorBy="cellColData",
	name="Sample",
	embedding="UMAP"
)


## To color UMAP by clusters


p2 <- plotEmbedding(
        ArchRProj=projP_2,
        colorBy="cellColData",
        name="Clusters",
        embedding="UMAP"
)


plotPDF(p1, p2,
	name="UMAP_by_Sample_Clusters.pdf",
	ArchRProj=projP_2,
	addDOC=FALSE,
	width=5, height=5)


# To visualize the plots side by side
ggAlignPlots(p1,p2,type="h")



#####################################################


# #To run a t-Stocastic Neighbor Embedding (tSNE)

projP_2 <- addTSNE(
	ArchRProj = projP_2,
	reducedDims = "IterativeLSI",
	name = "TSNE",
	perplexity = 30,
	seed = 1
)


#To plot the tSNE (the same parameters apply to colorBy and name regardless of the type of embedding used)

p1 <- plotEmbedding(
	ArchRProj = projP_2,
	colorBy = "cellColData",
	name = "Sample",
	embedding = "TSNE"
)

p2 <- plotEmbedding(
	ArchRProj = projP_2,
	colorBy = "cellColData",
	name = "Clusters",
	embedding = "TSNE"
)

ggAlignPlots(p1, p2, type = "h")

plotPDF(p1,p2, name = "TSNE-Sample-Clusters.pdf", ArchRProj = projP_2, addDOC = FALSE, width = 5, height = 5)



####################################################



## Dimensionality reduction after Harmony for UMAP

# Used to assess the effects of Harmony by visualizing the embedding using UMAP or tSNE and comparing this to the embeddings visualized previously for iterative LSI.
# Repeat the UMAP embedding with the same parameters but for the "Harmony" reduced Dims object


projP_2 <- addUMAP(
	ArchRProj = projP_2,
	reducedDims = "Harmony",
	name = "UMAPHarmony",
	nNeighbors = 30,
	minDist = 0.5, 
	metric = "cosine",
	seed = 1
)

p3 <- plotEmbedding( 
	ArchRProj = projP_2,
	colorBy = "cellColData", 
	name = "Sample",
	embedding = "UMAPHarmony"
)

p4 <- plotEmbedding(
	ArchRProj = projP_2,
	colorBy = "cellColData",
	name = "Clusters",
	embedding = "UMAPHarmony"
)

ggAlignPlots(p3, p4, type = "h")

plotPDF(p1,p2,p3,p4, name = "UMAP_Harmony_by_Sample_Clusters.pdf", ArchRProj = projP_2, addDOC = FALSE, width = 5, height = 5)


##############


# Dimensionality reduction after Harmony for tSNE

# Follow similar steps to those used for UMAP


projP_2 <- addTSNE(
        ArchRProj = projP_2,
        reducedDims = "Harmony",
        name = "TSNEHarmony",
        perplexity = 30,
        seed = 1
)

p3 <- plotEmbedding(
        ArchRProj = projP_2,
        colorBy = "cellColData",
        name = "Sample",
        embedding = "TSNEHarmony"
)

p4 <- plotEmbedding(
        ArchRProj = projP_2,
        colorBy = "cellColData",
        name = "Clusters",
        embedding = "TSNEHarmony"
)

ggAlignPlots(p3, p4, type = "h")

plotPDF(p1,p2,p3,p4, name = "TSNE_Harmony_by_Sample_Clusters.pdf", ArchRProj = projP_2, addDOC = FALSE, width = 5, height = 5)



#####################################################
#####################################################
#####################################################


## Gene scores and marker genes


markerGS <- getMarkerFeatures(
	ArchRProj = projP_2,
	useMatrix = "GeneScoreMatrix",
	groupBy = "Clusters",
	bias = c("TSSEnrichment", "log10(nFrags)"),
	testMethod = "wilcoxon"
)

markerList <- getMarkers(markerGS, cutOff = "FDR <= 0.01 & Log2FC >= 1.25")


# Marker list by cluster
markerList$C6


markerList.markers <- data.frame(getMarkers(markerGS, cutOff = "FDR <= 0.01 & abs(Log2FC) >= 1.25"))



for(i in names(markerList)) {
	write.csv(markerList[[i]], file = paste(i, ".csv", sep = ""))
}



#####################################################
#####################################################
#####################################################



##Use MAGIC to impute gene scores by smoothing signal across nearby cells

#Impute weights to the ArchRProject
projP_2 <- addImputeWeights(projP_2)



#####################################################
#####################################################
#####################################################


## Save projP_2

saveArchRProject(ArchRProj = projP_2, outputDirectory = "/project/eon/protocol_paper/Save-ProjP_2", load = FALSE)



#####################################################
#####################################################
#####################################################
